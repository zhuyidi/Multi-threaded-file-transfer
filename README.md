# **一. 项目描述**

## **1. 项目概述**

**本项目是一个基于中心化拓扑的P2P网络模型的文件传输系统, 旨在让客户端承担起分发文件的责任, 从而减轻服务端的负载.** 项目的服务端存有所有客户端所持有的资源信息,请求者向服务端请求一批文件时, 服务端进行资源检索, 并按照一定的策略给多个符合发送条件的客户端分配任务, 再由这多个客户端同时向请求者发送文件. 

## **2. 技术要点**

### **(1) 使用中心化拓扑结构的P2P网络编程模型**

P2P网络模型根据拓扑结构的不同可以分为四种拓扑形式: **中心化拓扑, 全分布式非结构化拓扑, 全分布式结构化拓扑, 半分布式拓扑.** 
中心化拓扑结构的P2P网络模型并非纯粹的P2P网络模型, 它类似于传统的C/S网络编程模型, 它由一个中央索引服务器和若干客户端组成. **中心化拓扑结构带来的好处就是资源查询效率高, 维护简单.** 由于资源的查询依赖中心化的目录系统, 所以资源的查询算法灵活高效并且能完成复杂查询.

**本项目使用中心化拓扑结构的P2P网络编程模型. 也就是说, 本项目的服务端就是中央索引服务器, 它存有所有的客户端所持有的资源信息. 当请求者请求资源的时候, 它能进行资源检索, 并根据发送策略决定由哪些客户端进行发送, 也就是说, 真正发送文件的是客户端**(有时也可能是服务端+多个客户端进行发送, 这点在后面的服务端设计中将详细介绍).

### **(2) 服务端的资源表使用Redis进行存储**

**1. 资源表的作用与结构?**

- **作用:** 每当有请求者请求文件, 服务端需要知道它所请求的每个文件分别被哪些端持有, 然后才能进行任务分配, 这就需要有一张表来记录每个端所持有的资源的情况. 
- **结构:** 使用Redis的Set数据结构进行存储. **资源表里的信息分为两部分, 即有两组Set. 一组Set的形式为Set&lt;某客户端, 某客户端持有的所有文件名&gt;, 另一组的Set的形式为Set&lt;某文件, 持有该文件的所有客户端&gt;.** 关于资源表的设计, 会在后面的服务端设计中详细阐述.

**2. 为什么使用Redis?**
当请求者请求一批文件时, 服务端需要决策由哪些客户端去给请求者发送文件, 此时, 服务端就需要一张存有个客户端所持有的资源信息的资源表. 之所以使用Redis进行资源表的存储有三个方面的原因:

- **(1) 缓存作用.**客户端向服务端请求文件这个操作是经常发生的, 也就是说需要经常访问资源表, 所以需要将它作为缓存, 以此提高访问速度.
- **(2) 可以对资源表的信息进行长期存储.** 由于本项目是基于中心化拓扑结构的P2P架构, 所以仍存在传统C/S架构存在的单点故障问题. 资源表信息是存储在服务端的, 一旦服务端宕机, 要求资源表的信息不能丢失, 所以使用Redis可以进行长期存储, 但在访问的时候速度又不会太慢.
- **(3) 简化业务逻辑. **使用Redis自身提供的Set数据结构可以将求交集并集这些操作委托给Redis来完成, 以此简化业务逻辑.

## **(2) 任务分配策略使用贪心算法**

在本项目中, 可以通过配置文件的方式来配置一次最多可有几个客户端同时向请求者发送文件. 
**假设现在最多可有n个端向请求者发送m个目标文件, 这n个符合发送条件的端所持有的目标文件是不尽相同的, 有可能这n个端可以将这m个目标文件全部分配完, 也有可能无法全部分配完(未分配的文件则由服务端发送), 这个时候我们就要寻求一组最优的客户端组合, 使得这一组客户端尽可能的将这m个目标文件全部分配完. **

## **(3) 使用多线程实现多端文件发送**

当服务端已经确定好由哪些客户端(即发送端)发送文件之后, 请求者就建立一个临时服务器, 与这些发送端进行连接, 每连接上一个发送端就新建一个接收线程接收文件, 这样实现多端同时发送文件.

## **(4) 使用观察者模式实现多模块之间的通信**

在本项目中, 由于有很多类, 并且类与类之间关系很复杂, 所以模块与模块之间的通信容易造成高耦合. 所以在项目中使用了观察者模式来实现多模块之间的通信.

比如现在有三个模块, 分别为接收模块, view模块(接收进度条的显示), 中央处理模块(比如每接收一个文件片段就在任务列表里面划掉这个文件片段). 那么, 它们之间的关系就是接收模块里面产生的信息需要传递给view模块和中央处理模块, 这种1 VS n 的关系就可以用观察者模式来解决. 接收模块实现Speaker接口, view模块和中央处理模块实现Listener接口并将自己注册为接收模块的监听者, 每当接收模块中有信息产生时, 就通过Speaker接口提供的方法传递给每一个Listener. 作为Speaker的类无需知道它的Listeners的实现类都是什么, 它只需要将信息推送给每一个Listener就可以了. 通过多对Speaker/Listener, 就可以实现多模块之间的复杂通信.

服务端的资源表用redis进行持久化，任务分配策略采用贪心算法，使用多线程实现多端文件发送，并使用观察者模式实现多模块之间的通信。
