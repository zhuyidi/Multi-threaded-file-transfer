# **一. 项目描述**

## **项目概述**

**本项目是一个基于中心化拓扑的P2P网络模型的文件传输系统, 旨在让客户端承担起分发文件的责任, 从而减轻服务端的负载.** 项目的服务端存有所有客户端所持有的资源信息,请求者向服务端请求一批文件时, 服务端进行资源检索, 并按照一定的策略给多个符合发送条件的客户端分配任务, 再由这多个客户端同时向请求者发送文件. 

# **二. 项目设计**

## **1. 服务端设计**

服务端主要有四个部分组成:ServerCenter, ServerDealMessage, ServerThread以及任务分配模块. 下面对这四个模块的功能进行简要介绍:

### **(1) ServerCenter**
**描述:** ServerCenter主要用来启动整个系统(比如创建ServerSocket, 启动Redis服务, 启动ServerSender等), 以及处理来自客户端的登录连接请求, 每连接上一个客户端, 就给其分配一个ServerThread与之通信.

### **(2) ServerDealMessage**
**描述:** ServerDealMessage用来解析并处服务端接收到的消息. 服务端与客户端之间的通信采用自定义协议格式(Message数据结构)来进行通信.

### **(3) ServerThread**
**描述:** ServerThread主要用来处理服务端与确定的某个客户端之间的通信.(也就是在ServerCenter中每连接上一个客户端, 就给它分配一个ServerThread维持与服务端的通信).

### **(4) 任务分配模块**
**描述:** 任务分配模块维护了服务端的资源表, 当有请求者向服务端请求资源的时候, 服务端对资源表进行检索, 得出两个Set集合, 即FileSet<文件, 拥有者列表>和ClientSet<客户端ID, 所拥有文件列表>. 

**分配策略:**

- (1) 服务端收到请求文件列表, 在资源表中求出这些FileSet的并集, 求出一个ClientIDSet, 也就是求出要完全发送这些文件, 至少需要哪些客户端的参与;
- (2) 然后在ClientIDSet中筛选出符合发送条件的客户端;
- (3) 选定这些客户端之后得到它们分别对应的ClientSet, 与需要的文件列表求交集, 得到它们每个端都可以发送这一批文件里面的哪些文件的集合;
- (4) 然后用贪心算法求出n个客户端能发送文件最多的组合(子集覆盖最大化问题);
- (5) 最终选定要参与发送的客户端, 并分配好任务(比如过大的文件就由两个端拆开发送), 就由服务器去通知任务, 并等待客户端的回复. 客户端将子集无法发送的文件名列表返回给服务端(如果为null就说明这个端可以完成任务), 服务端将这些没人发送的文件加入自己的任务列表, 亲自发送.

## **2. 客户端设计**
客户端主要由三个模块组成, 分别为Center, Receiver, Sender. 下面分别来介绍一下这三个模块的功能.

### **(1) Center**

Center主要负责客户端与服务端之间的通信, 它由细分为三个小模块:

- **ClientCenter:** 负责客户端的处理中心, 比如连接服务端. 当连接上服务费端之后就启动一个监听线程ClientThread, 用来监听来自服务端的Message.
- **ClientDealMessage:** 和ServerDealMessage模块功能类似, 主要负责Message的解析和处理.
- **ClientThread:** Client的监听线程, 主要监听来自服务端的MMessage.

### **(2) Receiver**

Receiver模块是Client作为请求者向服务端请求文件时接收文件模块.
它主要由三个小模块组成:

- **ReceiverCenter:** 文件接收中心. 文件接收中心主要用来控制接收服务器的建立与关闭(当请求者向服务端发送请求文件列表之后, 服务端返回sender端的个数之后就建立接收服务器, 当接收服务器上连接的sender端达到确定个数之后就断开接收服务器).
- **ReceiverServer:** 文件接收服务器, 连接要发送文件内容的Sender端, 每连接上一个Sender端, 就启动一个ReceiverThread线程.
- **ReceiverThread:** 用来接收Sender端发送的具体文件内容.

### **(3) Sender**

Sender模块比较简单, 所以将发送文件的功能都内聚在这一个类中, 它的主要功能就是连接请求者的接收文件服务器, 然后发送文件内容.


# **三. 技术要点**

### **1. 使用中心化拓扑结构的P2P网络编程模型**

P2P网络模型根据拓扑结构的不同可以分为四种拓扑形式: **中心化拓扑, 全分布式非结构化拓扑, 全分布式结构化拓扑, 半分布式拓扑.** 
中心化拓扑结构的P2P网络模型并非纯粹的P2P网络模型, 它类似于传统的C/S网络编程模型, 它由一个中央索引服务器和若干客户端组成. **中心化拓扑结构带来的好处就是资源查询效率高, 维护简单.** 由于资源的查询依赖中心化的目录系统, 所以资源的查询算法灵活高效并且能完成复杂查询.

**本项目使用中心化拓扑结构的P2P网络编程模型. 也就是说, 本项目的服务端就是中央索引服务器, 它存有所有的客户端所持有的资源信息. 当请求者请求资源的时候, 它能进行资源检索, 并根据发送策略决定由哪些客户端进行发送, 也就是说, 真正发送文件的是客户端**(有时也可能是服务端+多个客户端进行发送, 这点在后面的服务端设计中将详细介绍).

### **2. 服务端的资源表使用Redis进行存储**

**(1) 资源表的作用与结构?**

- **作用:** 每当有请求者请求文件, 服务端需要知道它所请求的每个文件分别被哪些端持有, 然后才能进行任务分配, 这就需要有一张表来记录每个端所持有的资源的情况. 
- **结构:** 使用Redis的Set数据结构进行存储. **资源表里的信息分为两部分, 即有两组Set. 一组Set的形式为Set&lt;某客户端, 某客户端持有的所有文件名&gt;, 另一组的Set的形式为Set&lt;某文件, 持有该文件的所有客户端&gt;.** 关于资源表的设计, 会在后面的服务端设计中详细阐述.

**(2) 为什么使用Redis?**
当请求者请求一批文件时, 服务端需要决策由哪些客户端去给请求者发送文件, 此时, 服务端就需要一张存有个客户端所持有的资源信息的资源表. 之所以使用Redis进行资源表的存储有三个方面的原因:
 
- **1. 缓存作用.** 客户端向服务端请求文件这个操作是经常发生的, 也就是说需要经常访问资源表, 所以需要将它作为缓存, 以此提高访问速度.
- **2. 可以对资源表的信息进行长期存储.** 由于本项目是基于中心化拓扑结构的P2P架构, 所以仍存在传统C/S架构存在的单点故障问题. 资源表信息是存储在服务端的, 一旦服务端宕机, 要求资源表的信息不能丢失, 所以使用Redis可以进行长期存储, 但在访问的时候速度又不会太慢.
- **3. 简化业务逻辑.** 使用Redis自身提供的Set数据结构可以将求交集并集这些操作委托给Redis来完成, 以此简化业务逻辑.

**资源表的持久化?**
资源表使用RDB方式进行持久化. 也就是说, 在下面三种情况下执行bgsave命令(非阻塞方式):

- 在900秒之后, 至少有1个key发生变化, 则dump内存快照;
- 在300秒之后, 至少有10个key发生变化, 则dump内存快照;
- 在60秒之后, 至少有10000个key发生变化, 则dump内存快照.

## **2. 任务分配策略使用贪心算法**

在本项目中, 可以通过配置文件的方式来配置一次最多可有几个客户端同时向请求者发送文件. 
**假设现在最多可有n个端向请求者发送m个目标文件, 这n个符合发送条件的端所持有的目标文件是不尽相同的, 有可能这n个端可以将这m个目标文件全部分配完, 也有可能无法全部分配完(未分配的文件则由服务端发送), 这个时候我们就要寻求一组最优的客户端组合, 使得这一组客户端尽可能的将这m个目标文件全部分配完.**

## **3. 使用多线程实现多端文件发送**

当服务端已经确定好由哪些客户端(即发送端)发送文件之后, 请求者就建立一个临时服务器, 与这些发送端进行连接, 每连接上一个发送端就新建一个接收线程接收文件, 这样实现多端同时发送文件.

## **4. 使用观察者模式实现多模块之间的通信**

在本项目中, 由于有很多类, 并且类与类之间关系很复杂, 所以模块与模块之间的通信容易造成高耦合. 所以在项目中使用了观察者模式来实现多模块之间的通信.

比如现在有三个模块, 分别为接收模块, view模块(接收进度条的显示), 中央处理模块(比如每接收一个文件片段就在任务列表里面划掉这个文件片段). 那么, 它们之间的关系就是接收模块里面产生的信息需要传递给view模块和中央处理模块, 这种1 VS n 的关系就可以用观察者模式来解决. 接收模块实现Speaker接口, view模块和中央处理模块实现Listener接口并将自己注册为接收模块的监听者, 每当接收模块中有信息产生时, 就通过Speaker接口提供的方法传递给每一个Listener. 作为Speaker的类无需知道它的Listeners的实现类都是什么, 它只需要将信息推送给每一个Listener就可以了. 通过多对Speaker/Listener, 就可以实现多模块之间的复杂通信.
